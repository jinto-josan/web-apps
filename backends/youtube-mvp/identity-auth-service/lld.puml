@startuml
title Identity-Auth Service - Low-Level Design

skinparam shadowing false
skinparam packageStyle rectangle
skinparam classAttributeIconSize 0
skinparam fontName "Helvetica"
skinparam titleFontName "Helvetica"
skinparam legendFontName "Helvetica"
skinparam noteFontName "Helvetica"
skinparam backgroundColor white
skinparam packageBackgroundColor lightblue
skinparam packageBorderColor darkblue
skinparam classBackgroundColor white
skinparam classBorderColor black
skinparam interfaceBackgroundColor lightgreen
skinparam interfaceBorderColor black

package "Domain Layer (Core)" <<clean>> {
    class User {
        -id: String
        -email: String
        -normalizedEmail: String
        -displayName: String
        -status: short
        -emailVerified: boolean
        -passwordHash: String
        -mfaEnabled: boolean
        -createdAt: Instant
        -updatedAt: Instant
        -version: Integer
    }
    
    class Session {
        -id: String
        -userId: String
        -jti: String
        -deviceId: String
        -userAgent: String
        -ip: String
        -revokedAt: Instant
        -revokeReason: String
    }
    
    class RefreshToken {
        -id: String
        -sessionId: String
        -tokenHash: byte[]
        -expiresAt: Instant
        -revokedAt: Instant
        -replacedByTokenId: String
    }
    
    interface UserRepository {
        +findByNormalizedEmail(email): Optional<User>
        +findById(userId): Optional<User>
        +save(user): User
        +existsByNormalizedEmail(email): boolean
    }
    
    interface SessionRepository {
        +findById(sessionId): Optional<Session>
        +save(session): Session
        +findByUserId(userId): List<Session>
    }
    
    interface RefreshTokenRepository {
        +findByTokenHash(hash): Optional<RefreshToken>
        +save(token): RefreshToken
        +findBySessionId(sessionId): List<RefreshToken>
    }
    
    interface EventPublisher {
        +publishUserCreated(event): void
        +publishUserUpdated(event): void
    }
    
    class UserCreated {
        -userId: String
        -email: String
        -displayName: String
        -emailVerified: boolean
        -status: short
        -createdAt: Instant
    }
    
    class UserUpdated {
        -userId: String
        -email: String
        -displayName: String
        -emailVerified: boolean
    }
    
    abstract class DomainEvent {
        -eventId: String
        -occurredAt: Instant
    }
    
    DomainEvent <|-- UserCreated
    DomainEvent <|-- UserUpdated
}

package "Application Layer" <<clean>> {
    interface AuthUseCase {
        +exchangeToken(command): TokenResponse
        +refreshToken(command): TokenResponse
        +revokeSession(command): void
        +getUser(query): User
    }
    
    class AuthUseCaseImpl {
        -verifier: OidcIdTokenVerifier
        -userRepository: UserRepository
        -sessionService: SessionRefreshService
        -tokenService: TokenService
        -eventPublisher: EventPublisher
        +exchangeToken(command): TokenResponse
        +refreshToken(command): TokenResponse
        +revokeSession(command): void
    }
    
    class ExchangeTokenCommand {
        -idToken: String
        -deviceId: String
        -userAgent: String
        -ip: String
        -scope: String
    }
    
    class RefreshTokenCommand {
        -refreshToken: String
        -scope: String
    }
    
    class RevokeSessionCommand {
        -refreshToken: String
    }
    
    class GetUserQuery {
        -userId: String
    }
    
    class TokenResponse {
        +accessToken: String
        +refreshToken: String
        +tokenType: String
        +expiresIn: long
        +scope: String
    }
    
    class OidcIdTokenVerifier {
        +verify(token): VerifiedIdentity
    }
    
    class TokenService {
        +newAccessToken(userId, sessionId, scope, claims): String
    }
    
    class SessionRefreshService {
        +createSessionWithRefresh(userId, deviceId, userAgent, ip): SessionWithRefresh
        +rotateRefreshOrThrow(refreshToken): RotationResult
        +revokeByRawRefreshToken(refreshToken): void
    }
    
    class DeviceFlowService {
        +start(verificationUri, clientId, scope): DeviceFlowStart
        +verify(userCode, userId): boolean
        +poll(deviceCode): PollResult
    }
}

package "Infrastructure Layer" <<clean>> {
    class UserEntity {
        -id: String
        -email: String
        -normalizedEmail: String
        -displayName: String
        -status: short
        -emailVerified: boolean
        +toDomain(): User
        +fromDomain(user): UserEntity
    }
    
    class UserJpaRepository {
        +findByNormalizedEmail(email): Optional<UserEntity>
        +findById(id): Optional<UserEntity>
        +save(entity): UserEntity
    }
    
    class UserRepositoryImpl {
        -jpaRepo: UserJpaRepository
        +findByNormalizedEmail(email): Optional<User>
        +findById(userId): Optional<User>
        +save(user): User
    }
    
    class SessionRepository {
        +findById(sessionId): Optional<Session>
        +save(session): Session
        +findByUserId(userId): List<Session>
    }
    
    class RefreshTokenRepository {
        +findByTokenHash(hash): Optional<RefreshToken>
        +save(token): RefreshToken
        +findBySessionId(sessionId): List<RefreshToken>
    }
    
    class EventPublisherImpl {
        -outboxRepository: OutboxRepository
        -objectMapper: ObjectMapper
        +publishUserCreated(event): void
        +publishUserUpdated(event): void
    }
    
    class OutboxRepository {
        +save(event): OutboxEvent
        +findTop100ByDispatchedAtIsNullOrderByCreatedAtAsc(): List<OutboxEvent>
        +markDispatched(id, messageId, dispatchedAt): void
    }
    
    class ServiceBusOutboxDispatcher {
        +dispatch(): void
    }
    
    class CompositeJwkProvider {
        +getKeyId(): String
        +getSigner(): JWSSigner
    }
    
    class KeyVaultJwkProvider {
        +getKeyId(): String
        +getSigner(): JWSSigner
    }
    
    class LocalRsaJwkProvider {
        +getKeyId(): String
        +getSigner(): JWSSigner
    }
    
    database "PostgreSQL" as DB {
        entity "auth.users" as UsersTable
        entity "auth.sessions" as SessionsTable
        entity "auth.refresh_tokens" as RefreshTokensTable
        entity "auth.outbox_events" as OutboxTable
    }
    
    node "Redis" as Redis {
        component "Session Cache" as SessionCache
        component "Device Flow State" as DeviceFlowState
    }
    
    cloud "Azure Services" as Azure {
        component "Azure AD B2C" as B2C
        component "Azure Key Vault" as KeyVault
        component "Azure Service Bus" as ServiceBus
    }
}

package "Interface Layer" <<clean>> {
    class AuthController {
        +exchange(command): TokenResponse
        +refresh(command): TokenResponse
        +logout(command): Map
    }
    
    class DeviceController {
        +start(request): DeviceStartResponse
        +activate(request): Map
        +poll(request): TokenResponse
    }
    
    class JwksController {
        +jwks(): JWKS
    }
    
    class AuthDtos {
        +ExchangeRequest
        +RefreshRequest
        +LogoutRequest
        +TokenResponse
        +DeviceStartRequest
        +DeviceStartResponse
    }
}

' Relationships
AuthController --> AuthUseCase
DeviceController --> DeviceFlowService
DeviceController --> OidcIdTokenVerifier
DeviceController --> SessionRefreshService
JwksController --> CompositeJwkProvider

AuthUseCase <|.. AuthUseCaseImpl
AuthUseCaseImpl --> UserRepository
AuthUseCaseImpl --> OidcIdTokenVerifier
AuthUseCaseImpl --> SessionRefreshService
AuthUseCaseImpl --> TokenService
AuthUseCaseImpl --> EventPublisher

UserRepository <|.. UserRepositoryImpl
SessionRepository <|.. SessionRefreshService
RefreshTokenRepository <|.. SessionRefreshService
EventPublisher <|.. EventPublisherImpl

UserRepositoryImpl --> UserJpaRepository
UserJpaRepository --> UserEntity
UserEntity --> UsersTable

SessionRepository --> SessionsTable
RefreshTokenRepository --> RefreshTokensTable

EventPublisherImpl --> OutboxRepository
OutboxRepository --> OutboxTable
ServiceBusOutboxDispatcher --> OutboxRepository
ServiceBusOutboxDispatcher --> ServiceBus

TokenService --> CompositeJwkProvider
CompositeJwkProvider --> KeyVaultJwkProvider
CompositeJwkProvider --> LocalRsaJwkProvider
KeyVaultJwkProvider --> KeyVault

OidcIdTokenVerifier --> B2C

SessionRefreshService --> SessionCache
DeviceFlowService --> DeviceFlowState

note right of UserRepository
  Domain repository interface
  No framework dependencies
end note

note right of UserRepositoryImpl
  Infrastructure implementation
  Bridges domain and JPA
end note

note right of EventPublisher
  Domain service interface
  Abstracts event publishing
end note

note right of EventPublisherImpl
  Uses transactional outbox pattern
  Reliable event publishing
end note

@enduml

