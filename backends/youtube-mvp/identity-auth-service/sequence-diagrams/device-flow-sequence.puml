@startuml Identity-Auth Service - Device Code Flow
skinparam fontName "Helvetica"
skinparam titleFontName "Helvetica"
skinparam legendFontName "Helvetica"
skinparam noteFontName "Helvetica"
autonumber
actor "TV Device" as TV
actor "Browser (User)" as Browser
participant "AuthController" as Controller
participant "StartDeviceFlowUseCase" as StartUC
participant "CompleteDeviceFlowUseCase" as ActivateUC
participant "DevicePollUseCase" as PollUC
participant "Azure Cache for Redis\n(DeviceFlowRepository)" as Redis
participant "UserRepository" as UserRepo
participant "SessionRepository" as SessionRepo
participant "TokenService" as TokenService
participant "KeyVaultSigner" as Signer
participant "Azure Key Vault" as KV
database "Azure SQL\n(users, sessions, refresh_tokens)" as SQL

group Start Device Flow
TV -> Controller: POST /auth/device/start { clientId, scope }
Controller -> StartUC: start(clientId, scope)
StartUC -> Redis: PUT device:code:{deviceCode} = payload TTL 900s
StartUC --> Controller: { deviceCode, userCode, verificationUri, interval, expiresIn }
Controller --> TV: 200 codes
end

group Activate Device Flow
Browser -> Controller: POST /auth/device/activate { userCode }\n(Authorization: bearer user JWT)
Controller -> ActivateUC: activate(userCode, userId)
ActivateUC -> Redis: GET by userCode -> deviceCode
alt found and status == PENDING
ActivateUC -> Redis: AUTHORIZE deviceCode with userId\nstatus=AUTHORIZED
ActivateUC --> Controller: 204
Controller --> Browser: 204
else not found/expired
ActivateUC --> Controller: 404
Controller --> Browser: 404
end
end

group Poll for Tokens
loop Poll every interval until authorized
TV -> Controller: POST /auth/device/poll { deviceCode }
Controller -> PollUC: poll(deviceCode)
PollUC -> Redis: GET device:code:{deviceCode}
alt status == AUTHORIZED
PollUC -> UserRepo: findById(authorizedUserId)
UserRepo --> PollUC: User
PollUC -> SessionRepo: save(new Session)
PollUC -> TokenService: issueFor(User, Session)
TokenService -> Signer: signJwt(claims)
Signer -> KV: Sign with RSA key
KV --> TokenService: signature
TokenService -> SQL: saveNew refresh token (hashed)
PollUC -> Redis: DELETE device:code:{deviceCode}
TokenService --> PollUC: TokenPair
PollUC --> Controller: TokenPair
Controller --> TV: 200 { accessToken, refreshToken }
break
else PENDING
Controller --> TV: 428 Pending
end
end
end
@enduml
