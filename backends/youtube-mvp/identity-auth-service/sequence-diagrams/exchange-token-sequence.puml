@startuml Identity-Auth Service - Exchange AAD id_token for platform tokens
skinparam fontName "Helvetica"
skinparam titleFontName "Helvetica"
skinparam legendFontName "Helvetica"
skinparam noteFontName "Helvetica"
autonumber
actor Client as Client
participant "AuthController" as Controller
participant "ExchangeTokenUseCase" as ExchangeUC
participant "OidcVerifier" as OIDC
participant "Azure AD (OIDC)" as AAD
database "Azure SQL\n(users, sessions, refresh_tokens)" as SQL
participant "Azure Cache for Redis" as Redis
participant "UserRepository" as UserRepo
participant "SessionRepository" as SessionRepo
participant "RefreshTokenRepository" as RefreshRepo
participant "TokenService" as TokenService
participant "KeyVaultSigner" as Signer
participant "Azure Key Vault" as KV

Client -> Controller: POST /auth/exchange { idToken }
Controller -> ExchangeUC: execute(idToken, clientInfo)
ExchangeUC -> OIDC: verifyIdToken(idToken)
OIDC -> AAD: GET /.well-known/jwks.json
AAD --> OIDC: JWKS
OIDC -> OIDC: Validate signature + claims
OIDC --> ExchangeUC: DecodedToken(sub, email, ...)
alt User exists by aadSubject
ExchangeUC -> UserRepo: findByAadSubject(sub)
UserRepo --> ExchangeUC: User
else New user or link by email
ExchangeUC -> UserRepo: findByEmail(email)
UserRepo --> ExchangeUC: Optional
alt not found
ExchangeUC -> UserRepo: save(new User with aadSubject)
UserRepo --> ExchangeUC: User
else found
ExchangeUC -> UserRepo: save(link aadSubject)
UserRepo --> ExchangeUC: User
end
end
ExchangeUC -> SessionRepo: save(new Session)
ExchangeUC -> TokenService: issueFor(User, Session)
TokenService -> Signer: signJwt(claims)
Signer -> KV: Sign with RSA key
KV --> Signer: signature
TokenService -> RefreshRepo: saveNew(sessionId, sha256(refreshToken), exp, replacedBy=null)
TokenService -> Redis: SET session:jti:{jti} TTL=15m
TokenService --> ExchangeUC: TokenPair
ExchangeUC --> Controller: TokenPair
Controller --> Client: 200 { accessToken, refreshToken, expiresIn }
@enduml
